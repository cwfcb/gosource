---

## 一、设计原理

### 1. 数据结构
`Ring` 结构体：
```go
type Ring struct {
    next, prev *Ring
    Value      any
}
```

- `next`、`prev`：指向下一个/上一个元素的指针，形成一个 **双向环形**。
- `Value`：用户存储的数据（任意类型 `any`）。
- 和 `list.List` 不同，`Ring` 没有哨兵节点，每一个节点都可以存储数据，结构本身就是环形。

---

### 2. 初始化
- `init()`：让一个节点的 `next` 和 `prev` 都指向自己，形成单节点环。
- `New(n)`：创建一个包含 `n` 个节点的环，每个节点的 `next` 和 `prev` 都正确链接，形成一个环。

---

### 3. 核心方法
#### (1) 遍历与移动
- `Next()` / `Prev()`：返回相邻节点，如果当前节点未初始化（`next == nil`），则初始化为单节点环。
- `Move(n)`：向前（n > 0）或向后（n < 0）移动 n 步，支持负值。

#### (2) 链接与拆分
- `Link(s)`：
  - 如果 `r` 和 `s` 属于同一个环，`Link(s)` 会把 `r.Next()` 到 `s.Prev()` 之间的节点移出，并返回它们组成的子环。
  - 如果 `r` 和 `s` 属于不同环，会把 `s` 的整个环插入到 `r` 之后，形成一个新的大环。
- `Unlink(n)`：
  - 移除从 `r.Next()` 开始的 n 个节点，返回它们组成的子环。

#### (3) 长度与遍历
- `Len()`：遍历整个环计算长度。
- `Do(f)`：对每个节点执行函数 `f`（前向遍历）。

---

### 4. 设计特点
- **环形结构**：首尾连接，不需要额外的哨兵节点。
- **节点等价**：每个节点都是可存储数据的节点，可以作为遍历起点。
- **固定长度**：默认创建时指定长度，后续可通过 `Link/Unlink` 调整。
- **无额外头尾标记**：不像 `list.List` 有一个 `root` 哨兵，`Ring` 任意节点都可以代表整个环。

---

## 二、使用场景

### 1. 适合的场景
- **循环迭代**：
  - 例如轮询调度（round-robin）、循环队列。
  - 可以用 `Move()` 快速在环中前后跳转。
- **固定容量结构**：
  - 比如定长缓冲区、游戏玩家循环队列。
- **算法应用**：
  - 约瑟夫环（Josephus Problem）等需要环形结构的算法。
- **双向循环遍历**：
  - 同时支持前向和后向遍历。

---

### 2. 不适合的场景
- **频繁按索引访问**：
  - `Ring` 不支持 O(1) 随机访问，需要遍历。
- **需要频繁插入删除任意位置**：
  - 虽然有 `Link` 和 `Unlink`，但操作相对复杂，且 `Len()` 是 O(n)。
- **大规模数据存储**：
  - 每个节点单独分配内存，内存局部性差。

---

## 三、注意事项

1. **节点未初始化时 `next == nil`**
   - 所有方法都会先检测 `next` 是否为 nil，如果是则调用 `init()`。
   - 所以可以用零值节点，但访问前会初始化为单节点环。

2. **环中任意节点都可作为起点**
   - 没有头尾概念，遍历到起点结束。
   - 因此存储时要注意，环的起点可能是任意节点。

3. **`Link` 和 `Unlink` 的行为**
   - 如果两个节点属于同一环，`Link` 会“切断”一段形成子环。
   - 如果属于不同环，`Link` 会“拼接”两个环。
   - 返回值永远是原来的 `r.Next()`（或子环起点）。

4. **`Len()` 是 O(n)**
   - 不像 `list.List` 有 `len` 字段，`Ring` 每次计算长度都要遍历整个环。

5. **并发安全**
   - `Ring` 不是线程安全的，并发读写需要外部加锁。

6. **`Do()` 中不要修改环结构**
   - 文档明确说明：`Do` 的行为在 `f` 改变环结构时是未定义的。

---

## 四. `Unlink` 的作用

源码：
```go
func (r *Ring) Unlink(n int) *Ring {
    if n <= 0 {
        return nil
    }
    return r.Link(r.Move(n + 1))
}
```

它的含义是：

> 从当前节点 `r.Next()` 开始**移除** `n % r.Len()` 个节点，返回这段被移除的子环。移除后，原环的剩余部分直接连起来。

注意：
- `r` 本身不会被移除。
- 移除的是 `r.Next()` 起的那 `n` 个节点。
- 返回值是被移除的那段子环的起点。

---

### 内部原理

`Unlink(n)` 实际上是通过调用 `Link()` 来实现的。

`Link(s)` 的定义是：
- 把当前节点 `r` 的下一个节点替换成 `s`。
- 同时让 `s.Prev()` 的下一个节点指向原 `r.Next()` 的前一个节点。
- 如果 `r` 和 `s` 在同一个环里，这会把中间的那段节点拆出来形成一个新的子环。

在 `Unlink` 里，`s` 是通过：
```go
r.Move(n + 1)
```
得到的，也就是：
- 从 `r` 向前移动 `n + 1` 步，得到新的位置 `s`。

---

### 图解示例

假设我们有一个环：
```
   [r] → A → B → C → D → E → (回到 r)
```
这里 `[r]` 是当前节点。

### 调用：
```go
sub := r.Unlink(3)
```

**步骤 1：移动**
- `Move(n + 1)` = `Move(4)` 从 `r` 开始向前移动 4 步：
```
r → A(1) → B(2) → C(3) → D(4)
```
得到 `s = D`。

**步骤 2：Link 操作**
调用：
```go
r.Link(s)
```
把 `r.Next()` 改成 `s`，并修正 `prev` / `next` 指针。

原结构：
```
r → A → B → C → D → E → (回到 r)
```
在同一个环中执行 `Link(s)` 会：
- 从 `r.Next()` 到 `s.Prev()` （即 A → B → C）这一段**拆出来**。
- 让 `r` 直接指向 `D`，`D.Prev` 指向 `r`。
- 拆出来的那段 A → B → C 自成一个子环，返回它。

**结果：**

剩余主环：
```
[r] → D → E → (回到 r)
```

返回的子环：
```
A → B → C → (回到 A)
```

---

### 为什么是 `n + 1`
这里的 +1 是因为：
- `Link(s)` 会把 `r.Next()` 到 `s.Prev()` 之间的节点拆出来。
- 如果你想拆出 `n` 个节点，从 `r.Next()` 开始数 `n` 个，`s` 必须是第 `n+1` 个节点的位置（因为 `s.Prev()` 是第 `n` 个）。

---

### 小总结
- **`Unlink(n)`**：从 `r.Next()` 开始，移除 `n` 个节点，返回它们组成的子环。
- **原理**：通过 `Move(n+1)` 找到断开点 `s`，然后 `Link(s)` 切断原环并返回拆出的子环。
- **特点**：
  - O(n) 时间（因为 `Move` 和 `Link` 都可能遍历）。
  - 不会影响当前节点 `r`，只是缩短原环长度。
  - 返回的子环是一个独立的环结构，可以继续操作或丢弃。

---

## 五、与 `container/list` 的区别

| 特性            | `container/list`        | `container/ring`             |
|-----------------|-------------------------|------------------------------|
| 结构类型        | 双向链表（有哨兵节点）  | 双向环形链表（无哨兵节点）    |
| 长度存储        | 有 `len` 字段（O(1)）   | 没有长度字段（O(n) 计算）     |
| 节点存储数据    | 哨兵不存储数据          | 所有节点可存储数据            |
| 插入/删除复杂度 | O(1)                    | O(1)（需操作指针）            |
| 遍历方式        | 从 `Front()` 到 `nil`   | 从任意节点回到起点            |
| 使用场景        | 灵活插入删除、队列、缓存 | 循环迭代、固定容量、轮询调度   |

---

✅ **总结**：
- **设计原理**：`Ring` 是一个双向环形链表，节点等价，无哨兵，任意节点可作为起点。
- **使用场景**：适合循环迭代、轮询调度、固定容量的数据结构。
- **注意事项**：`Len()` 是 O(n)，`Do()` 内不要修改结构，未初始化节点会自动变成单节点环。

---