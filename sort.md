# 1. 二分查找：`sort.Search`

### 1.1. 核心功能

`sort.Search` 实现了一个通用的**二分查找（Binary Search）**算法。

它的目标是在一个虚拟的、长度为 `n` 的索引范围 `[0, n)` 内，找到满足某个条件 `f(i)` 的 **最小索引 `i`**。

### 1.2. 最重要的前提条件

`sort.Search` 能够正确工作，必须依赖一个非常重要的假设：你提供给它的函数 `f(i)` 在 `[0, n)` 这个区间上必须是 **单调的**。具体来说，这个函数 `f` 的表现必须像这样：

*   对于区间 `[0, n)` 的一个（可能为空的）前缀部分，`f(i)` 全部返回 `false`。
*   对于区间的剩余部分（可能为空），`f(i)` 全部返回 `true`。

换句话说，整个 `[0, n)` 区间可以被划分为两段：

```
[false, false, ..., false, true, true, ..., true]
```

`sort.Search` 的任务就是高效地找到那个从 `false` 变为 `true` 的分界点，也就是第一个返回 `true` 的索引。

### 1.3. 返回值

*   如果找到了这样的索引 `i`，函数就返回这个最小的 `i`。
*   如果对于 `[0, n)` 范围内的所有索引，`f(i)` 都返回 `false`，那么函数返回 `n`。
*   如果对于 `[0, n)` 范围内的所有索引，`f(i)` 都返回 `true`，那么函数返回 `0`。

**特别注意**：当找不到满足条件的值时，它返回的是 `n`（即范围的上限），而不是像 `strings.Index` 那样返回 `-1`。这个 `n` 有着特殊的含义，即“插入点”。

### 1.4. 最常见的用途：在已排序的切片中查找

虽然 `sort.Search` 本身很通用，但它最常见的应用场景是在一个已排序的切片中查找某个值 `x`。

文档中的例子非常经典，我们来分解一下：

假设你有一个升序排列的整数切片 `data`，你想在里面查找 `x = 23`。

```go
x := 23
i := sort.Search(len(data), func(i int) bool { return data[i] >= x })
```

*   `len(data)`：定义了搜索范围是 `[0, len(data))`。
*   `func(i int) bool { return data[i] >= x }`：这是关键。我们来分析这个函数 `f` 的行为：
    *   因为 `data` 是升序的，所以对于切片开头那些小于 23 的元素，`data[i] >= 23` 会返回 `false`。
    *   当 `i` 增长到某个位置，`data[i]` 第一次大于或等于 23 时，`data[i] >= 23` 开始返回 `true`。
    *   对于那之后的所有元素，`data[i] >= 23` 会一直返回 `true`。

这就完美地满足了 `[false, ..., true, ...]` 的前提条件。因此，`sort.Search` 返回的 `i` 就是切片中第一个大于或等于 23 的元素的位置。

### 1.5. 如何利用返回值

`sort.Search` 只告诉你 **应该在哪里** 找到目标值，但它 **不保证** 那个位置上的值就是目标值。所以，你需要一个额外的步骤来确认：

```go
if i < len(data) && data[i] == x {
    // 找到了！x 就在索引 i 的位置。
} else {
    // 没找到。
    // 但是，i 是 x 如果要插入到 data 中以保持排序时，应该插入的位置。
}
```

*   `i < len(data)`：这个检查是必须的。如果 `x` 比 `data` 中所有元素都大，`Search` 会返回 `len(data)`，此时 `data[i]` 会越界。
*   `data[i] == x`：确认该位置上的元素确实是我们想找的 `x`。

### 1.7. 总结

`sort.Search` 是一个强大、灵活的二分查找工具。它将“如何进行二分查找”的算法逻辑和“在什么条件下进行查找”的业务逻辑完全解耦。你只需要提供一个满足单调性的判断函数 `f`，它就能在任何满足该条件的有序集合或概念空间中，为你找到分界点。

# 2. 更方便的二分查找：`sort.Find`

### 2.1. 核心功能

`sort.Find` 同样使用**二分查找（Binary Search）**算法，在一个虚拟的、长度为 `n` 的索引范围 `[0, n)` 内查找。

与 `sort.Search` 不同的是，它不使用返回 `bool` 的函数，而是使用一个 **三路比较函数** `cmp(i)`，这个函数需要返回 `int` 类型：

*   `> 0` (+1)：表示目标值 **大于** 当前索引 `i` 处的元素。
*   `== 0`：表示目标值 **等于** 当前索引 `i` 处的元素（找到了匹配！）。
*   `< 0` (-1)：表示目标值 **小于** 当前索引 `i` 处的元素。

### 2.2. 前提条件

`sort.Find` 能够正确工作的前提是，你提供的 `cmp(i)` 函数在 `[0, n)` 区间上必须是 **单调递减** 的。具体来说，`cmp(i)` 的返回值必须遵循以下模式：

*   对于区间的一个（可能为空的）前缀，`cmp(i)` 全部返回 `> 0`。
*   对于区间中间的一个（可能为空的）部分，`cmp(i)` 全部返回 `== 0`。
*   对于区间的剩余后缀部分，`cmp(i)` 全部返回 `< 0`。

换句话说，整个 `[0, n)` 区间可以被划分为三段：

```
[ >0, >0, ..., ==0, ==0, ..., <0, <0, ... ]
```

`sort.Find` 的任务就是高效地找到第一个 `cmp(i) <= 0` 的位置。

### 2.3. 返回值

`sort.Find` 返回两个值，这使它比 `sort.Search` 更方便：

*   `i (int)`：
    *   函数找到的第一个满足 `cmp(i) <= 0` 的索引。
    *   如果找到了一个或多个精确匹配（`cmp(i) == 0`），`i` 就是 **第一个** 精确匹配的索引。
    *   如果没有找到精确匹配，`i` 就是目标值应该被 **插入** 以维持排序的位置。
    *   如果 `cmp(i)` 对所有 `i` 都返回 `> 0`（即目标值比所有元素都大），则返回 `n`。
*   `found (bool)`：
    *   一个布尔值，明确地告诉你是否找到了 **精确匹配**。
    *   当且仅当函数返回的 `i < n` 并且 `cmp(i) == 0` 时，`found` 才为 `true`。

### 2.4. 与 `sort.Search` 的关键区别

| 特性 | `sort.Search` | `sort.Find` |
| :--- | :--- | :--- |
| **判断函数** | `f(i) bool` | `cmp(i) int` |
| **返回值** | `i int` | `i int, found bool` |
| **后续操作** | 需要手动检查 `data[i] == x` | 无需额外检查，直接使用 `found` |
| **便利性** | 较低，需要两步操作（Search + Check） | 更高，一步到位 |

`sort.Find` 将“查找”和“确认”这两个步骤合并成了一个原子操作，代码更简洁，意图也更明确。

### 2.5. 示例解读

文档中的例子清晰地展示了它的用法：

```go
// 假设 x 是一个已排序的、支持 Len() 和 At(i) 方法的数据结构
// target 是我们要查找的字符串

i, found := sort.Find(x.Len(), func(i int) int {
    // strings.Compare 完美地提供了三路比较
    return strings.Compare(target, x.At(i))
})

if found {
    // 直接使用 found 判断，无需再次比较
    fmt.Printf("found %s at entry %d\n", target, i)
} else {
    // 没找到，但 i 告诉了我们插入点
    fmt.Printf("%s not found, would insert at %d", target, i)
}
```
`strings.Compare(a, b)` 的行为：
*   如果 `a > b`，返回 `+1`。
*   如果 `a == b`，返回 `0`。
*   如果 `a < b`，返回 `-1`。

当 `target` 与 `x.At(i)` 比较时，`strings.Compare` 的返回值完美地满足了 `sort.Find` 对 `cmp` 函数的前提要求（对于升序列表 `x`）。

### 2.6. 总结

`sort.Find` 是一个更符合人体直觉的二分查找函数。当你能很自然地对目标值和集合中的元素进行三路比较（大于、等于、小于）时，`sort.Find` 是比 `sort.Search` 更好的选择。它通过返回一个明确的 `found` 标志，简化了代码逻辑，降低了因忘记检查而导致的错误风险。