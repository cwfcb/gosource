你已经有一个 `RandN()` 函数，可以返回 **均匀分布** 的 `[0, N]`（包含 0 和 N）之间的整数随机数。  
现在你想实现一个 `RandM()` 函数，返回 `[0, M]` 的均匀随机数，并且希望有一种**通用的设计方法**。

---

## 一、通过 RandN() 生成 RandM() 的通用方法

### 1. 基本思路
这是一个典型的**随机数转换**问题：  
已知一个均匀随机源，如何生成另一个范围的均匀随机数。

**核心原则**：
- 保证每个目标数的概率相等（均匀性）
- 尽量减少丢弃（避免 bias）

### 2. 拒绝采样方法
假设 `RandN()` 返回 `[0, N]` 之间的整数，均匀分布。我们想生成 `[0, M]` 之间的均匀整数。

#### 2.1 M <= N 的情况
实现简单，直接拒绝采样：
```c
int RandM() {
    int r;
    do {
        r = RandN();
    } while (r > M);
    return r;
}
```
- 把范围超过 M 的结果丢掉，重新生成。
- 缺点：如果 M 接近 N，效率还好；如果 M 很小而 N 很大，效率会降低。

#### 2.2 M > N 的情况
需要组合多个 `RandN()` 的结果，扩展随机空间：
- `RandN()` 返回 [0, N]，可看作随机一个 **位数**（或进制是 N+1 的一位数）。
- 组合多个调用，相当于生成更大的随机数范围。

```c
// 生成一个 [0, (N+1)^k - 1] 的随机数
int RandK(int k) {
    int num = 0;
    for (int i = 0; i < k; ++i) {
        num = num * (N+1) + RandN();
    }
    return num;
}
```

然后：
- 找到最小的 k，使 `(N+1)^k >= M+1`
- 用拒绝采样把超出范围的数丢掉

```c
int RandM() {
    int k = 1;
    while (pow(N+1, k) < M+1) k++;

    int limit = M+1;
    int maxRange = pow(N+1, k);

    int r;
    do {
        r = RandK(k);
    } while (r >= limit);

    return r;
}
```

这样可以保证均匀分布。

### 3. 通用设计方法总结

1. **表示能力分析**  
   - 已知均匀整数源的范围 `[0, N]`，其熵为 `log2(N+1)` 位。
   - 目标范围 `[0, M]`，需要 `log2(M+1)` 位熵。
   
2. **组合随机源**  
   - 如果目标范围比源范围大，组合多个调用，构造更大的随机空间。
   - 用进制 `(N+1)` 的多位数表示，得到足够大的范围。

3. **拒绝采样**  
   - 用生成的大范围随机数去映射到 `[0, M]`。
   - 丢弃超出范围的结果，重新生成，保持均匀性。

4. **优化**  
   - 选择最小 k，使 `(N+1)^k >= M+1`，减少拒绝的概率。
   - 如果 N+1 刚好能整除 M+1，可以直接映射而无需拒绝采样。

### 4. 一个具体例子

假设：
- 已有 `Rand5()`（返回 0~5）
- 想实现 `Rand7()`（返回 0~7）

步骤：
1. `N=5`，`M=7`
2. N+1 = 6
3. 找最小 k: 6^1=6 < 8，6^2=36 >= 8，所以 k=2
4. 组合两个 Rand5：
   ```c
   int r;
   do {
       r = Rand5() * 6 + Rand5(); // 0~35
   } while (r >= 8);
   return r;
   ```

这样就能保证均匀分布。

### 5. 结论
通用方法是：
- 把已有随机源看成某进制的单个数字
- 组合多位，得到大于等于目标范围的随机空间
- 用拒绝采样丢弃超范围的值
- 保证均匀性

---

### 6. 拒绝采样的浪费与优化

#### 6.1 浪费的根源
在拒绝采样里，浪费的根源是：  
我们生成的随机数空间大小 **S**（比如 \((N+1)^k\)），并不能整除目标空间大小 \(M+1\)，所以会有一部分结果无法映射到目标范围中，只能丢弃。

浪费比例大约是：
\[
\frac{S - (M+1)}{S}
\]
当 \(M+1\) 接近 \(S\) 时浪费很小；相反，如果 \(M+1\) 远小于 \(S\)，浪费很大。

#### 6.2 优化方向

##### 方案 A：选择最优的 k
- 在基本方法里，我们是找最小的 k，使 \((N+1)^k \ge M+1\)。
- 这已经是减少浪费的第一步，因为 k 越大，**S** 越大，浪费比例可能下降，但调用 RandN 次数增加。
- 可以在 k 和浪费比例之间做平衡：
    - 如果浪费比例很大，可以考虑让 k 再加 1，使 S 更接近 M 的倍数，从而减少丢弃率。
    - 但这会增加 RandN 调用次数，可能不划算。

##### 方案 B：多阶段利用剩余空间
拒绝采样时丢弃的“超范围数”，其实仍然是均匀的，可以把它们作为新的随机源继续生成目标数，而不是直接丢掉。

举个例子：
- 假设我们生成了一个 [0, 35] 的数，要映射到 [0, 7]。
- 我们可以取前 32 个（0~31）直接映射到目标范围（比如取模），剩下的 4 个（32~35）其实是 [0, 3] 的均匀随机数。
- 这 [0, 3] 的随机数可以和另一次 RandN 结果组合，继续生成新的目标数。
- 这样可以减少浪费，但实现会更复杂。

这种方法本质上是**递归利用剩余空间**，类似于“分桶”或“随机位缓冲池”的思想。

##### 方案 C：转为位流（Bit Stream）
如果 \((N+1)\) 是 2 的幂，比如 Rand3（0~3）可以看作 2 位随机数，那么：
- 可以直接把源随机数拆成二进制位流，按需拼接成目标范围所需的位数。
- 位流方法几乎没有浪费，因为所有位都会被用到。
- 如果 N+1 不是 2 的幂，也可以先用拒绝采样把它转成位流（比如 Rand5 转成 Rand2），再用位流生成目标数。

**核心思想**：很多随机数生成问题，本质上就是**从已有的随机源中提取足够多的随机比特（bits）**，再用这些比特组合成我们需要的目标随机数。比特是最小的“随机信息单位”，我们可以按需拼接成任意大小的随机数，避免了拒绝采样时丢弃整个随机数的情况。

**具体例子**：
假设我们有 `Rand3()`（返回 0~3，即 2 位随机比特），想实现 `Rand5()`（返回 0~5）：
1. 调用两次 `Rand3()`，得到 4 比特，拼接成 0~15 的数
2. 用拒绝采样选取 0~5：
   - 如果结果 ≤ 5，直接返回
   - 如果结果 > 5，把多余的比特放回缓冲区（不浪费），继续生成

这种方法的好处是：
- 在连续生成大量随机数时，浪费率极低
- 适合需要高效批量生成的场景

#### 6.3 实战建议
- **偶尔生成**：用最小 k + 拒绝采样就够了，简单且正确
- **高频、大量生成**：考虑用 **剩余空间递归利用** 或 **位流缓冲池** 方法，显著减少浪费

#### 6.4 优化小结
- 拒绝采样浪费的本质是源空间和目标空间不匹配
- 优化方法：
    1. 选择最优的 k（源空间最接近目标空间）
    2. 递归利用剩余空间
    3. 转换为位流（适合批量场景）
- 如果只是偶尔调用，浪费可以接受；批量生成时才值得优化

---

## 二、Go 标准库 `rand.Perm` 函数实现剖析

### 1. 作用
`Perm` 函数是 Go 标准库 `math/rand` 包里的一个方法，用来生成一个长度为 `n` 的**随机排列**（permutation）——也就是把 `[0, n)` 之间的整数打乱顺序，返回一个切片。

- 输入：一个整数 `n`。
- 输出：一个长度为 `n` 的 `[]int` 切片，包含 `0, 1, ..., n-1`，但顺序是**随机的且不重复**。
- 用途：洗牌、随机抽签、随机化测试数据顺序等。

### 2. 算法原理
它实现的是 **Fisher–Yates 洗牌算法**（又叫 Knuth shuffle），保证每个排列出现的概率相等。

### 3. 代码流程解析
```go
func (r *Rand) Perm(n int) []int {
    m := make([]int, n) // 创建一个长度为 n 的切片

    // 循环 i 从 0 到 n-1
    for i := 0; i < n; i++ {
        j := r.Intn(i + 1) // 从 [0, i] 区间随机选一个索引 j
        m[i] = m[j]        // 把 m[j] 的值放到 m[i]
        m[j] = i           // 把当前 i 放到 m[j]
    }
    return m
}
```

### 4. 关键点
- **`r.Intn(i+1)`**：返回一个 `[0, i]` 区间的随机索引，保证已经生成的部分也会被打乱。
- **交换操作**：
    - `m[i] = m[j]`：把 m[j] 的值复制到 m[i]。
    - `m[j] = i`：把当前 i 放到 m[j]。
- 最终 `m` 中的每个位置都会被随机分配到 `[0, n)` 的某个整数，且不会重复。

### 5. 为什么保留 i=0 的迭代？
源码的注释解释了一个历史原因：
- 当 `i=0` 时，`j` 只能是 0，所以 `m[0] = m[0]` 没有实际交换作用，这步是“没意义”的。
- 按理可以让循环从 `i=1` 开始，跳过这次无用交换。
- **但是**：`Perm` 的随机性依赖于 `r` 的内部状态，每次调用会影响 RNG 的状态。如果改成 `i=1`，会少一次 `Intn` 调用，导致 RNG 状态变化不同，破坏了 Go 1 的兼容性。所以保留了这次无用迭代。

### 6. 使用示例
```go
r := rand.New(rand.NewSource(time.Now().UnixNano()))
fmt.Println(r.Perm(5))
```
可能输出：
```
[3 0 4 1 2]
```
含义：原本 `[0, 1, 2, 3, 4]` 被随机打乱成 `[3, 0, 4, 1, 2]`。

### 7. 流程示例
假设 `n = 5`，初始 `m` 切片全是零值 `[0, 0, 0, 0, 0]`：

| i | 随机 j | 操作后 m |
|---|--------|----------|
| 0 | 0      | [0, 0, 0, 0, 0] |
| 1 | 0      | [1, 0, 0, 0, 0] |
| 2 | 1      | [1, 2, 0, 0, 0] |
| 3 | 2      | [1, 2, 3, 0, 0] |
| 4 | 3      | [1, 2, 3, 4, 0] |

最终输出就是某个随机排列。

### 8. 关键点记忆
- `Intn(i+1)` 确保每个位置都有等概率被选择。
- 这种「随机插入」的过程在数学上等价于均匀洗牌，保证所有 `n!` 种排列出现的概率相等。
- 保留 `i=0` 的迭代是为了兼容 Go 1 的 RNG 状态。

---

✅ **总结**  
本文分为两大部分：
1. **通过 RandN() 生成 RandM()**：介绍了基于拒绝采样的通用方法，以及如何优化采样效率
2. **Go 标准库 rand.Perm 分析**：详细解析了其实现的 Fisher–Yates 洗牌算法和设计细节
