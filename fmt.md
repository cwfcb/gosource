## 一、设计原理

`fmt` 包的核心设计思想是为 Go 提供 **格式化输入输出**（Formatted I/O），类似于 C 语言的 `printf`/`scanf` 系列，但更简洁、类型安全、与 Go 语法一致。

主要设计理念：
1. **统一的格式化语法**  
   使用 `%verb` 这样的占位符（称为“格式动词”），不同类型有不同的 verb，比如 `%d` 输出整数，`%s` 输出字符串，`%v` 输出默认格式等。
   
2. **与 Go 类型系统结合**  
   - `%T` 可以直接输出变量的类型。
   - `%#v` 输出 Go 语法形式，便于调试。
   - 对实现特定接口的类型（如 `Stringer`、`error`、`Formatter`）会调用它们的自定义方法。

3. **默认递归格式化**  
   对复合类型（struct、slice、map 等）会递归调用相同的规则来格式化元素，而不是输出原始内存。

4. **安全与健壮性**  
   - 如果类型与 verb 不匹配，会输出错误提示（如 `%!d(string=hi)`）。
   - 防止无限递归（虽然不主动检测自引用，但建议用户避免）。
   - 遇到 panic 会包装错误信息。

5. **扫描功能设计**  
   除了打印，`fmt` 还提供 `Scan` 系列函数来解析输入，支持从 `os.Stdin`、`io.Reader` 或字符串中读取，类似 C 的 `scanf`，但更安全和灵活。

---

## 二、主要功能与使用方法

### 1. 打印函数
- **无格式**：
  - `fmt.Print(a, b, ...)`：按默认 `%v` 输出各参数，不加换行。
  - `fmt.Println(a, b, ...)`：加空格分隔，并在末尾加 `\n`。
- **有格式**：
  - `fmt.Printf(format, a, b, ...)`：按指定格式化输出。
  - `fmt.Sprintf`：返回格式化后的字符串。
  - `fmt.Fprintf(w, format, ...)`：输出到指定 `io.Writer`。


### 2. 扫描函数
- 从标准输入：
  - `fmt.Scan(&a, &b, ...)`：按空格分隔读取。
  - `fmt.Scanln(&a, &b, ...)`：读到换行结束。
  - `fmt.Scanf(format, &a, &b, ...)`：按格式读取。
- 从自定义 Reader：
  - `fmt.Fscan(r, ...)`
  - `fmt.Fscanln(r, ...)`
  - `fmt.Fscanf(r, format, ...)`
- 从字符串：
  - `fmt.Sscan(str, ...)`
  - `fmt.Sscanln(str, ...)`
  - `fmt.Sscanf(str, format, ...)`

特点：
- 自动跳过空格（除了 `%c`）。
- `%s` 和 `%v` 读到空格或换行停止。
- 支持整数前缀（`0b`、`0o`、`0x`）。
- 支持下划线分隔数字（`123_456`）。


### **Go fmt Verb 对照速查表**

#### 通用（General）
| Verb   | 说明 | 示例 (`fmt.Printf`) | 注意事项 |
|--------|------|--------------------|----------|
| `%v`   | 默认格式输出 | `%v` → `map[a:1 b:2]` | 复合类型递归输出 |
| `%+v`  | 默认格式 + 结构体字段名 | `%+v` → `{Name:Tom Age:18}` | 仅结构体字段名 |
| `%#v`  | Go 语法表示 | `%#v` → `map[string]int{"a":1,"b":2}` | 便于调试/复制 |
| `%T`   | 输出类型 | `%T` → `map[string]int` | 类型含包路径 |
| `%%`   | 字面 `%` | `%%` → `%` | 不消耗参数 |

---

#### 布尔（Boolean）
| Verb | 说明 | 示例 | 注意事项 |
|------|------|------|----------|
| `%t` | 输出 `true`/`false` | `%t` → `true` | 仅布尔类型 |

---

#### 整数（Integer）
| Verb  | 说明 | 示例 | 注意事项 |
|-------|------|------|----------|
| `%b`  | 二进制 | `%b` → `1010` | 无前缀，配 `#` 有 `0b` |
| `%c`  | 按 Unicode 码点输出字符 | `%c` → `A` | 需 int/rune |
| `%d`  | 十进制 | `%d` → `42` | 常用整数输出 |
| `%o`  | 八进制 | `%o` → `52` | 无前缀，`%#o` 有 `0` |
| `%O`  | 八进制（`0o` 前缀） | `%O` → `0o52` | Go 1.13+ |
| `%q`  | 单引号字符，Go 语法转义 | `%q` → `'A'` | rune 时有效 |
| `%x`  | 十六进制（小写） | `%x` → `2a` | `%#x` 有 `0x` |
| `%X`  | 十六进制（大写） | `%X` → `2A` | `%#X` 有 `0X` |
| `%U`  | Unicode 格式 | `%U` → `U+0041` | `%#U` → `U+0041 'A'` |

---

#### 浮点 / 复数（Floating-point / Complex）
| Verb  | 说明 | 示例 | 注意事项 |
|-------|------|------|----------|
| `%b`  | 二进制指数形式 | `%b` → `123456p-78` | 内部表示 |
| `%e`  | 科学计数法（小写 e） | `%e` → `1.234000e+02` | 默认精度 6 |
| `%E`  | 科学计数法（大写 E） | `%E` → `1.234000E+02` | 同上 |
| `%f`  | 小数点，无指数 | `%f` → `123.456000` | 默认精度 6 |
| `%F`  | 同 `%f` | `%F` → `123.456000` | |
| `%g`  | 大数用 `%e`，否则 `%f` | `%g` → `123.456` | 精度＝有效位数 |
| `%G`  | 同 `%g`，E 大写 | `%G` → `123.456` | |
| `%x`  | 十六进制浮点（小写） | `%x` → `0x1.23p+02` | |
| `%X`  | 十六进制浮点（大写） | `%X` → `0X1.23P+02` | |
| **复数** | `(实+虚i)`，每部分按 verb 输出 | `%f` → `(1.200000+3.400000i)` | 宽度精度分别作用于实部和虚部 |

---

#### 字符串 / []byte
| Verb | 说明 | 示例 | 注意事项 |
|------|------|------|----------|
| `%s` | 原样输出 | `%s` → `hello` | |
| `%q` | 双引号 + Go 语法转义 | `%q` → `"hello"` | |
| `%x` | 每字节转小写十六进制 | `%x` → `68656c6c6f` | 精度按字节数 |
| `%X` | 每字节转大写十六进制 | `%X` → `68656C6C6F` | |

---

#### 指针（Pointer）
| Verb | 说明 | 示例 | 注意事项 |
|------|------|------|----------|
| `%p` | 十六进制地址（0x 前缀） | `%p` → `0xc00000a0b0` | `%#p` 去掉 `0x` |
| `%b/%d/%o/%x/%X` | 按整数值格式化指针 | `%x` → `c00000a0b0` | 不常用 |

---

#### Flags（标志）
| Flag | 说明 | 示例 | 常与 verb 搭配 |
|------|------|------|----------------|
| `+`  | 数字强制显示符号 | `%+d` → `+42` | 数值、`%q` |
| `-`  | 左对齐 | `%-6d` → `42    ` | 所有数值/字符串 |
| `#`  | 备用格式（前缀/强制小数点等） | `%#x` → `0x2a` | `%b` `%o` `%x` `%q` `%U` `%e` `%f` `%g` |
| ` `  | 数字正号留空位 | `% d` → ` 42` | 数值、`% x` |
| `0`  | 用 0 填充宽度 | `%06d` → `000042` | 数值 |

---

#### 宽度与精度（Width and Precision）
- **宽度**：最小输出字符数，不足填充空格（或 `0`）。
- **精度**：
  - 字符串：最大输出长度（按 rune 数）。
  - 浮点：小数位数（`%6.2f` → `12.34`）。
  - `%g/%G`：有效数字位数。
- **动态宽度/精度**：用 `*` 从参数取值  
  例：`fmt.Printf("%*.*f", 8, 3, 12.3456)` → `"  12.346"`

---

#### 扫描（Scan 系列）verb 对应
与打印 verb 类似，但不支持：
- `%T`（类型）
- `%p`（指针地址）
- Flags `#` 和 `+` 无效  
读取规则：
- 除 `%c` 外，都会跳过前导空格。
- `%s`、`%v`（读字符串）遇空格或换行停止。
- 支持数字下划线分隔和进制前缀（0b、0o、0x）。

---

#### 常见错误输出
| 情况 | 输出示例 |
|------|----------|
| 类型不匹配 | `%!d(string=hi)` |
| 多余参数 | `%!(EXTRA string=guys)` |
| 缺少参数 | `%!d(MISSING)` |
| 宽度/精度类型错误 | `%!(BADWIDTH)` / `%!(BADPREC)` |
| 参数索引错误 | `%!d(BADINDEX)` |
| panic | `%!s(PANIC=bad)` |
---

## 三、注意事项

1. **类型匹配**  
   Verb 和类型必须匹配，否则会生成 `%!verb(type=value)` 错误输出。

2. **接口方法调用顺序**  
   - 如果类型是 `reflect.Value`，先取其内部值。
   - 如果实现了 `Formatter`，优先调用它。
   - `%#v` 且实现了 `GoStringer`，调用它。
   - 如果是 `%s/%q/%x/%X/%v`，且实现了 `error` 或 `Stringer`，调用它们的方法。

3. **复合类型递归格式化**  
   `%q` 会作用到 slice 中每个 string 元素，而不是整个 slice。

4. **指针与 nil**  
   - `%p` 输出地址。
   - 如果调用 `String()` 或 `Error()` 时接收器是 nil，则输出 `<nil>`。

5. **宽度与精度**  
   - 宽度是最小字符数，不够则填充。
   - 精度控制小数位数（浮点）或截断长度（字符串）。
   - 可用 `*` 让宽度/精度从参数获取。

6. **显式参数索引**  
   - `%[n]verb` 按第 n 个参数格式化。
   - `%[3]*.[2]*[1]f` 指定宽度/精度的参数索引。

7. **扫描时的换行与空格规则**  
   与 C 不同：Go 的扫描对换行有特殊处理，不是简单的空格。

8. **性能注意**  
   - `fmt` 功能丰富但不一定是最快的输出方式，简单场景可用 `strconv` 或 `bytes.Buffer`。

---

## 四、总结

**fmt 包设计哲学**：
- 提供统一、简洁、与 Go 类型系统结合的格式化输出输入接口。
- 高度兼容 C printf/scanf 风格，但简化并更安全。
- 结合接口实现（`Stringer`、`Formatter`）来支持自定义格式。
- 递归处理复合类型，方便调试。

**使用建议**：
- 调试时多用 `%#v` 查看 Go 语法形式。
- 输出结构体时用 `%+v` 带字段名。
- 宽度精度控制可用在表格或数值对齐。
- 注意 verb 与类型匹配，防止错误输出。
- 扫描时要处理好输入空格和换行规则。