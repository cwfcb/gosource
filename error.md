
## 1. 设计原理

### 错误链（Error Tree）
在 Go 1.13 之后，错误可以通过 `Unwrap()` 方法包裹其他错误形成链（或树）：

- `Unwrap() error`：返回被包裹的单个错误
- `Unwrap() []error`：返回多个子错误（例如多错误场景）

这使得一个错误对象可以携带“根本原因”以及多个相关的上下文。

---

### `errors.Is`
**作用**：判断 `err` 链中是否有一个错误与 `target` 匹配。

**匹配规则**：
1. **直接比较（==）**：如果 `target` 是可比较的类型（即类型的值可用 `==` 比较），则直接比较值。
2. **类型自定义匹配**：如果错误类型实现了 `Is(error) bool` 方法，则调用它来自定义匹配逻辑（例如 `os.PathError` 可以匹配 `fs.ErrExist`）。
3. **递归遍历错误链**：调用 `Unwrap()` 深度优先遍历所有子错误，直到找到匹配的。

**设计目标**：
- 支持包装错误的匹配（即使不是同一个实例）
- 支持跨类型的等价判断（通过实现 `Is` 方法）

---

### `errors.As`
**作用**：在 `err` 链中查找第一个能赋值给 `target` 指针的错误，并把它赋值进去。

**匹配规则**：
1. 如果 `err` 的具体类型（`reflect.TypeOf(err)`) 可赋值给 `target` 指向的类型，则直接赋值。
2. 如果错误类型实现了 `As(any) bool` 方法，则由该方法负责进行类型转换/赋值。
3. 同样递归遍历错误链（深度优先）。

**设计目标**：
- 安全地提取错误的具体类型
- 支持自定义类型转换（通过实现 `As` 方法）

---

## 2. 使用场景

### `Is` 使用场景
当你关心 **错误的类别** 或 **是否等价于某个已知错误** 时，用 `Is`：

```go
if errors.Is(err, os.ErrNotExist) {
    // 文件不存在
}
```

例如：
- 网络超时检测：`errors.Is(err, context.DeadlineExceeded)`
- 权限错误检测：`errors.Is(err, fs.ErrPermission)`

---

### `As` 使用场景
当你需要获得 **错误的具体类型** 从而访问额外字段时，用 `As`：

```go
var pathErr *os.PathError
if errors.As(err, &pathErr) {
    fmt.Println("操作失败的路径:", pathErr.Path)
}
```

例如：
- 从包装的错误中拿到自定义类型字段
- 进行类型特定的处理（如重试、日志）

---

## 3. 为什么不推荐直接用 `==` 比较错误

在 Go 1.13 之前，常见的错误比较方式是：

```go
if err == os.ErrNotExist { ... }
```

但这种方式有几个问题：

1. **无法匹配被包装的错误**  
   如果错误被 `fmt.Errorf("... %w", err)` 包装过，`==` 比较会失败，即使本质上是同一个错误类型。

2. **无法匹配等价但不同实例的错误**  
   有些错误类型是结构体，两个结构体实例即使值相同也可能不被认为是同一个错误（尤其是包含时间戳、路径等额外信息）。

3. **无法支持自定义等价逻辑**  
   某些错误类型可能希望与另一个错误等价（例如 `MyError.Is(target)`），但 `==` 无法调用这种逻辑。

4. **潜在的比较 panic**  
   某些错误值的类型不可比较（包含 slice、map 等），直接 `==` 会 panic。

---

## 4. 总结
- **`errors.Is`**：判断错误链中是否有某个错误等价于 `target`（类别匹配）
- **`errors.As`**：提取错误链中第一个可以赋值给 `target` 类型的错误（类型匹配）
- **不要用 `==`**：因为它不能处理包装错误、类型等价逻辑、不可比较类型等情况
- **推荐用 `Is` / `As`**：它们支持错误链和自定义匹配/转换，是现代 Go 错误处理的标准方式

---